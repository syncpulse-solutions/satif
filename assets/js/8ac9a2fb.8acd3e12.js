"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4571],{2984:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"standardizers/ai_standardizer","title":"AIStandardizer","description":"\u26a0\ufe0f EXPERIMENTAL: This is an experimental implementation not intended for production use. Despite the async API, there may be blocking I/O calls that could impact performance in production async environments.","source":"@site/docs/standardizers/ai_standardizer.md","sourceDirName":"standardizers","slug":"/standardizers/ai_standardizer","permalink":"/satif/docs/standardizers/ai_standardizer","draft":false,"unlisted":false,"editUrl":"https://github.com/syncpulse-solutions/satif/tree/main/docs/docs/standardizers/ai_standardizer.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Standardizers","permalink":"/satif/docs/standardizers"},"next":{"title":"AI CSV Standardizer","permalink":"/satif/docs/standardizers/ai_csv_standardizer"}}');var r=t(4848),a=t(8453);const s={sidebar_position:1},d="AIStandardizer",o={},l=[{value:"1. Basic Usage",id:"1-basic-usage",level:2},{value:"2. Initialization Parameters",id:"2-initialization-parameters",level:2},{value:"3. Supported File Types",id:"3-supported-file-types",level:2},{value:"4. Input Types",id:"4-input-types",level:2},{value:"5. Standardization Method Parameters",id:"5-standardization-method-parameters",level:2},{value:"6. Output",id:"6-output",level:2},{value:"7. Error Handling",id:"7-error-handling",level:2},{value:"8. Extending Supported File Types",id:"8-extending-supported-file-types",level:2}];function c(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"aistandardizer",children:"AIStandardizer"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"\u26a0\ufe0f EXPERIMENTAL: This is an experimental implementation not intended for production use. Despite the async API, there may be blocking I/O calls that could impact performance in production async environments."})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"AIStandardizer"})," is a component designed to orchestrate the standardization of various file types using specialized AI-driven standardizers. It processes a datasource (which can include individual files or ZIP archives), dispatches files to appropriate AI agents (e.g., ",(0,r.jsx)(n.code,{children:"AICSVStandardizer"}),", ",(0,r.jsx)(n.code,{children:"AIXLSXStandardizer"}),"), and merges their SDIF outputs into a single, standardized file."]}),"\n",(0,r.jsx)(n.h2,{id:"1-basic-usage",children:"1. Basic Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from satif_ai.standardizers.ai import AIStandardizer\nfrom pathlib import Path\n\n# Initialize the standardizer\nstandardizer = AIStandardizer(\n    llm_model="gpt-4.1"  # Optional: specify the LLM model to use\n)\n\n# Define input and output paths\ninput_files = ["data1.csv", "data2.xlsx"]\noutput_path = "standardized_output.sdif"\n\n# Execute standardization\nresult = await standardizer.standardize(\n    datasource=input_files,\n    output_path=output_path,\n    overwrite=True\n)\n\nprint(f"Standardization complete. Output at: {result.output_path}")\n'})}),"\n",(0,r.jsx)(n.h2,{id:"2-initialization-parameters",children:"2. Initialization Parameters"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"AIStandardizer"})," accepts several parameters to customize its behavior:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'standardizer = AIStandardizer(\n    llm_model=None,           # Optional: Language model identifier (e.g., "gpt-4.1")\n    sdif_schema=None,         # Optional: Schema for SDIF schema enforcement\n    tidy_adapter=None         # Optional: Adapter for data tidying\n)\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"llm_model"})}),": Identifier for the language model to use for AI standardization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"sdif_schema"})}),": Optional schema definition for SDIF adaptation (as file path or dict)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"tidy_adapter"})}),": Optional adapter for data tidying operations"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"3-supported-file-types",children:"3. Supported File Types"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"AIStandardizer"})," supports various file types through specialized standardizers:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CSV files"})," (",(0,r.jsx)(n.code,{children:".csv"}),"): Processed by ",(0,r.jsx)(n.code,{children:"AICSVStandardizer"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Excel files"})," (",(0,r.jsx)(n.code,{children:".xlsx"}),", ",(0,r.jsx)(n.code,{children:".xls"}),", ",(0,r.jsx)(n.code,{children:".xlsm"}),"): Processed by ",(0,r.jsx)(n.code,{children:"AIXLSXStandardizer"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Support for additional file types can be added by extending the ",(0,r.jsx)(n.code,{children:"ai_standardizer_map"})," dictionary."]}),"\n",(0,r.jsx)(n.h2,{id:"4-input-types",children:"4. Input Types"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"standardize"})," method accepts various forms of input datasources:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Single file path (string or Path)\nresult = await standardizer.standardize(\n    datasource="path/to/file.csv",\n    output_path="output.sdif"\n)\n\n# List of file paths\nresult = await standardizer.standardize(\n    datasource=["file1.csv", "file2.xlsx"],\n    output_path="output.sdif"\n)\n\n# Directory path (all supported files in the directory will be processed)\nresult = await standardizer.standardize(\n    datasource="path/to/directory",\n    output_path="output.sdif"\n)\n\n# ZIP archive (will be extracted and processed)\nresult = await standardizer.standardize(\n    datasource="archive.zip",\n    output_path="output.sdif"\n)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"5-standardization-method-parameters",children:"5. Standardization Method Parameters"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"standardize"})," method accepts the following parameters:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"result = await standardizer.standardize(\n    datasource=input_files,          # Required: Input data source(s)\n    output_path=output_path,         # Required: Path for the output SDIF file\n    overwrite=False,                 # Optional: Whether to overwrite existing output\n    config=None                      # Optional: Configuration options for standardizers\n)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"datasource"})}),": Input source data (single file path, list of paths, or directory path)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"output_path"})}),": Path where the standardized SDIF file will be written"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"overwrite"})}),": Boolean flag to control whether existing output files should be overwritten"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"config"})}),": Optional dictionary with configuration options passed to child standardizers"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"6-output",children:"6. Output"}),"\n",(0,r.jsxs)(n.p,{children:["The standardization process returns a ",(0,r.jsx)(n.code,{children:"StandardizationResult"})," object with:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"output_path"})}),": Path to the generated SDIF file"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"file_configs"})}),": Optional configurations for the processed files"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'result = await standardizer.standardize(...)\nprint(f"Output SDIF file: {result.output_path}")\nif result.file_configs:\n    print(f"File configurations: {result.file_configs}")\n'})}),"\n",(0,r.jsx)(n.h2,{id:"7-error-handling",children:"7. Error Handling"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"AIStandardizer"})," provides comprehensive error handling:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"ValueError"})}),": Raised for invalid input parameters or empty datasources"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"FileNotFoundError"})}),": Raised when input files don't exist"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"FileExistsError"})}),": Raised when output exists and ",(0,r.jsx)(n.code,{children:"overwrite=False"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"RuntimeError"})}),": Raised for processing errors during standardization"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'try:\n    result = await standardizer.standardize(\n        datasource=input_files,\n        output_path=output_path\n    )\nexcept FileNotFoundError as e:\n    print(f"Input file not found: {e}")\nexcept ValueError as e:\n    print(f"Invalid input parameter: {e}")\nexcept RuntimeError as e:\n    print(f"Processing error: {e}")\n'})}),"\n",(0,r.jsx)(n.h2,{id:"8-extending-supported-file-types",children:"8. Extending Supported File Types"}),"\n",(0,r.jsxs)(n.p,{children:["To add support for additional file types, extend the ",(0,r.jsx)(n.code,{children:"ai_standardizer_map"})," dictionary:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from satif_ai.standardizers.ai import AIStandardizer\nfrom my_package.standardizers import AIPDFStandardizer\n\n# Create standardizer with extended support\nstandardizer = AIStandardizer()\nstandardizer.ai_standardizer_map[".pdf"] = AIPDFStandardizer\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Custom standardizers must inherit from ",(0,r.jsx)(n.code,{children:"AsyncStandardizer"})," and implement the required interface."]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>d});var i=t(6540);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);