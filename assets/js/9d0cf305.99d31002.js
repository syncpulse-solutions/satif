"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6979],{4470:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"merge_sdif()","title":"Merging SDIF Files","description":"The mergesdiffiles utility provides a robust mechanism to consolidate multiple SDIF files into a single, new SDIF file. This is useful for combining datasets that have been standardized separately.","source":"@site/docs/merge_sdif().md","sourceDirName":".","slug":"/merge_sdif()","permalink":"/satif/docs/merge_sdif()","draft":false,"unlisted":false,"editUrl":"https://github.com/syncpulse-solutions/satif/tree/main/docs/docs/merge_sdif().md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8}}');var t=s(4848),r=s(8453);const d={sidebar_position:8},l="Merging SDIF Files",a={},o=[{value:"Function Signature",id:"function-signature",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Returns",id:"returns",level:2},{value:"Core Merging Heuristics and Rules",id:"core-merging-heuristics-and-rules",level:2},{value:"1. Target SDIF File",id:"1-target-sdif-file",level:3},{value:"2. Single File Input",id:"2-single-file-input",level:3},{value:"3. Metadata Tables (<code>sdif_</code>)",id:"3-metadata-tables-sdif_",level:3},{value:"<code>sdif_properties</code>",id:"sdif_properties",level:4},{value:"<code>sdif_sources</code>",id:"sdif_sources",level:4},{value:"<code>sdif_tables_metadata</code> and <code>sdif_columns_metadata</code> (User Data Tables)",id:"sdif_tables_metadata-and-sdif_columns_metadata-user-data-tables",level:4},{value:"<code>sdif_objects</code>",id:"sdif_objects",level:4},{value:"<code>sdif_media</code>",id:"sdif_media",level:4},{value:"<code>sdif_semantic_links</code>",id:"sdif_semantic_links",level:4},{value:"<code>sdif_annotations</code>",id:"sdif_annotations",level:4},{value:"Error Handling",id:"error-handling",level:2},{value:"Example",id:"example",level:2}];function c(e){const i={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"merging-sdif-files",children:"Merging SDIF Files"})}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"merge_sdif_files"})," utility provides a robust mechanism to consolidate multiple SDIF files into a single, new SDIF file. This is useful for combining datasets that have been standardized separately."]}),"\n",(0,t.jsx)(i.h2,{id:"function-signature",children:"Function Signature"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:"from pathlib import Path\nfrom typing import List\nfrom satif_core.types import SDIFPath\n\ndef merge_sdif_files(sdif_paths: List[SDIFPath], output_path: Path) -> Path:\n    # ... implementation ...\n"})}),"\n",(0,t.jsx)(i.h2,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:[(0,t.jsx)(i.code,{children:"sdif_paths"})," (List[SDIFPath])"]}),": A list of paths to the source SDIF files that need to be merged."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:[(0,t.jsx)(i.code,{children:"output_path"})," (Path)"]}),": The full file path where the newly merged SDIF file will be saved.\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Its parent directory will be created if it doesn't exist."}),"\n",(0,t.jsxs)(i.li,{children:["If ",(0,t.jsx)(i.code,{children:"output_path"})," points to an existing file, that file ",(0,t.jsx)(i.strong,{children:"will be overwritten"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:["If ",(0,t.jsx)(i.code,{children:"output_path"})," points to an existing directory, a ",(0,t.jsx)(i.code,{children:"ValueError"})," is raised."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"returns",children:"Returns"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"(Path)"}),": The path to the newly created and merged SDIF file (this will be the same as the ",(0,t.jsx)(i.code,{children:"output_path"})," provided)."]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"core-merging-heuristics-and-rules",children:"Core Merging Heuristics and Rules"}),"\n",(0,t.jsx)(i.p,{children:"The merge process iterates through each source SDIF file and integrates its contents into a new target SDIF database according to the following rules:"}),"\n",(0,t.jsx)(i.h3,{id:"1-target-sdif-file",children:"1. Target SDIF File"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["A new SQLite database is created at the specified ",(0,t.jsx)(i.code,{children:"output_path"}),". If a file already exists at ",(0,t.jsx)(i.code,{children:"output_path"}),", it is overwritten."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"2-single-file-input",children:"2. Single File Input"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["If ",(0,t.jsx)(i.code,{children:"sdif_paths"})," contains only one file path:\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"No actual merge operation is performed."}),"\n",(0,t.jsxs)(i.li,{children:["The single source SDIF file is copied directly to the ",(0,t.jsx)(i.code,{children:"output_path"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:["If the source file and ",(0,t.jsx)(i.code,{children:"output_path"})," are identical, no copy occurs."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.h3,{id:"3-metadata-tables-sdif_",children:["3. Metadata Tables (",(0,t.jsx)(i.code,{children:"sdif_"}),")"]}),"\n",(0,t.jsx)(i.h4,{id:"sdif_properties",children:(0,t.jsx)(i.code,{children:"sdif_properties"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.code,{children:"sdif_version"})}),": The ",(0,t.jsx)(i.code,{children:"sdif_version"})," from the ",(0,t.jsx)(i.code,{children:"sdif_properties"})," table of the ",(0,t.jsx)(i.em,{children:"first"})," SDIF file in the ",(0,t.jsx)(i.code,{children:"sdif_paths"})," list is used for the merged file.\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Heuristic"}),': It\'s assumed all source SDIF files conform to the same base SDIF specification (currently "1.0"). The function will raise a ',(0,t.jsx)(i.code,{children:"ValueError"}),' if a source SDIF has a version other than "1.0".']}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.code,{children:"creation_timestamp"})}),": This is set to the Coordinated Universal Time (UTC) when the entire merge operation successfully completes for the target merged file."]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"sdif_sources",children:(0,t.jsx)(i.code,{children:"sdif_sources"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["All entries from the ",(0,t.jsx)(i.code,{children:"sdif_sources"})," table of each source SDIF are copied into the target SDIF's ",(0,t.jsx)(i.code,{children:"sdif_sources"})," table."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:[(0,t.jsx)(i.code,{children:"source_id"})," Remapping"]}),": New ",(0,t.jsx)(i.code,{children:"source_id"})," primary keys are generated in the target database. A mapping from the (source file index, old ",(0,t.jsx)(i.code,{children:"source_id"}),") to the new ",(0,t.jsx)(i.code,{children:"source_id"})," is maintained internally to update references in other tables (like ",(0,t.jsx)(i.code,{children:"sdif_tables_metadata"}),", ",(0,t.jsx)(i.code,{children:"sdif_objects"}),", ",(0,t.jsx)(i.code,{children:"sdif_media"}),")."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.code,{children:"processing_timestamp"})}),": The original ",(0,t.jsx)(i.code,{children:"processing_timestamp"})," for a source is not directly carried over. The ",(0,t.jsx)(i.code,{children:"SDIFDatabase.add_source()"})," method, when adding these sources to the target, will generate a new ",(0,t.jsx)(i.code,{children:"processing_timestamp"})," reflecting when that source entry was added to the ",(0,t.jsx)(i.em,{children:"merged"})," file."]}),"\n"]}),"\n",(0,t.jsxs)(i.h4,{id:"sdif_tables_metadata-and-sdif_columns_metadata-user-data-tables",children:[(0,t.jsx)(i.code,{children:"sdif_tables_metadata"})," and ",(0,t.jsx)(i.code,{children:"sdif_columns_metadata"})," (User Data Tables)"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Schema Integration"}),": For each user data table found in a source SDIF:\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["The table's schema (column names, SQLite types, ",(0,t.jsx)(i.code,{children:"NOT NULL"}),", ",(0,t.jsx)(i.code,{children:"PRIMARY KEY"}),", ",(0,t.jsx)(i.code,{children:"FOREIGN KEY"})," constraints, descriptions, original column names) is retrieved from the source SDIF using ",(0,t.jsx)(i.code,{children:"SDIFDatabase.get_schema()"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Table Name Conflict Resolution"}),":\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Heuristic"}),": If a table name from a source SDIF already exists in the target merged SDIF (due to a previous source SDIF having a table with the same name), a unique name is generated by appending an underscore and a sequential number (e.g., ",(0,t.jsx)(i.code,{children:"my_table"})," becomes ",(0,t.jsx)(i.code,{children:"my_table_1"}),", then ",(0,t.jsx)(i.code,{children:"my_table_2"}),", etc.)."]}),"\n",(0,t.jsx)(i.li,{children:"This new (or original, if no conflict) table name is used for creation in the target and for remapping any references."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:[(0,t.jsx)(i.code,{children:"source_id"})," Update"]}),": The ",(0,t.jsx)(i.code,{children:"source_id"})," in ",(0,t.jsx)(i.code,{children:"sdif_tables_metadata"})," is updated to the new ",(0,t.jsx)(i.code,{children:"source_id"})," generated for its original source in the target database."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Foreign Key (FK) Remapping"}),":\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Heuristic"}),": Foreign key constraints defined within a source SDIF are assumed to target tables ",(0,t.jsx)(i.em,{children:"also originating from that same source SDIF file"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:["When a table is created in the target, its FK definitions are updated to point to the new (potentially renamed) names of its target tables ",(0,t.jsx)(i.em,{children:"as they exist in the current merge context (i.e., after their own potential renaming)"}),"."]}),"\n",(0,t.jsx)(i.li,{children:"Cross-SDIF file foreign key relationships are not automatically established or inferred by this merge process."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Data Copying"}),": All rows from the source table are copied into the newly created (and potentially renamed) table in the target SDIF.\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Type Handling"}),": Basic data type conversions are applied to align pandas DataFrame types with SQLite expectations during insertion (e.g., Python booleans to integers 0/1, pandas ",(0,t.jsx)(i.code,{children:"NaT"})," to ",(0,t.jsx)(i.code,{children:"None"}),", datetime objects to ISO 8601 strings)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"sdif_objects",children:(0,t.jsx)(i.code,{children:"sdif_objects"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Each JSON object entry from a source ",(0,t.jsx)(i.code,{children:"sdif_objects"})," table is copied."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:[(0,t.jsx)(i.code,{children:"object_name"})," Conflict Resolution"]}),": Similar to table names, if an ",(0,t.jsx)(i.code,{children:"object_name"})," already exists in the target, a unique name (e.g., ",(0,t.jsx)(i.code,{children:"my_object_1"}),") is generated."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:[(0,t.jsx)(i.code,{children:"source_id"})," Update"]}),": The ",(0,t.jsx)(i.code,{children:"source_id"})," is remapped to its new value in the target."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:[(0,t.jsx)(i.code,{children:"json_data"})," and ",(0,t.jsx)(i.code,{children:"schema_hint"})]}),": The JSON content and schema hint are preserved."]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"sdif_media",children:(0,t.jsx)(i.code,{children:"sdif_media"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Each media asset entry from a source ",(0,t.jsx)(i.code,{children:"sdif_media"})," table is copied."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:[(0,t.jsx)(i.code,{children:"media_name"})," Conflict Resolution"]}),": Unique names are generated for ",(0,t.jsx)(i.code,{children:"media_name"})," if conflicts arise (e.g., ",(0,t.jsx)(i.code,{children:"my_image_1"}),")."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:[(0,t.jsx)(i.code,{children:"source_id"})," Update"]}),": The ",(0,t.jsx)(i.code,{children:"source_id"})," is remapped."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:[(0,t.jsx)(i.code,{children:"media_data"})," and Metadata"]}),": The binary ",(0,t.jsx)(i.code,{children:"media_data"})," (BLOB) and all associated metadata (",(0,t.jsx)(i.code,{children:"media_type"}),", ",(0,t.jsx)(i.code,{children:"description"}),", ",(0,t.jsx)(i.code,{children:"original_format"}),", ",(0,t.jsx)(i.code,{children:"technical_metadata"}),") are preserved."]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"sdif_semantic_links",children:(0,t.jsx)(i.code,{children:"sdif_semantic_links"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Entries from the ",(0,t.jsx)(i.code,{children:"sdif_semantic_links"})," table are copied."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:["Element Specification Remapping (",(0,t.jsx)(i.code,{children:"from_element_spec"}),", ",(0,t.jsx)(i.code,{children:"to_element_spec"}),")"]}),":\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["The JSON content of ",(0,t.jsx)(i.code,{children:"from_element_spec"})," and ",(0,t.jsx)(i.code,{children:"to_element_spec"})," is parsed."]}),"\n",(0,t.jsxs)(i.li,{children:["If these specifications refer to elements by name (e.g., ",(0,t.jsx)(i.code,{children:"table_name"}),", ",(0,t.jsx)(i.code,{children:"object_name"}),", ",(0,t.jsx)(i.code,{children:"media_name"}),"), these names are updated to their new (potentially conflict-resolved) names in the target merged SDIF."]}),"\n",(0,t.jsxs)(i.li,{children:["If a specification contains a ",(0,t.jsx)(i.code,{children:"source_id"})," (relevant for certain ",(0,t.jsx)(i.code,{children:"element_type"})," values, though less common directly in link specs compared to annotations), it's also remapped."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Heuristic"}),": Links are assumed to be self-contained within the scope of elements originating from the ",(0,t.jsx)(i.em,{children:"same source SDIF file"}),". The remapping ensures these internal links remain consistent after potential renaming of their constituent parts."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"sdif_annotations",children:(0,t.jsx)(i.code,{children:"sdif_annotations"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Not Merged"}),": The ",(0,t.jsx)(i.code,{children:"sdif_annotations"})," table is ",(0,t.jsx)(i.strong,{children:"not"})," processed or merged in the current version of ",(0,t.jsx)(i.code,{children:"merge_sdif_files"}),". Its contents from source SDIFs will not be present in the merged output file. This is an optional table per RFC SP-RFC-002, and merging it involves significant complexity in remapping target elements."]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(i.p,{children:"The function may raise common exceptions, including:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.code,{children:"ValueError"})}),": If ",(0,t.jsx)(i.code,{children:"sdif_paths"})," is empty, or ",(0,t.jsx)(i.code,{children:"output_path"})," is an existing directory or otherwise invalid."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.code,{children:"FileNotFoundError"})}),": If any of the specified source SDIF files in ",(0,t.jsx)(i.code,{children:"sdif_paths"})," do not exist."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:[(0,t.jsx)(i.code,{children:"sqlite3.Error"})," (and subclasses)"]}),": For underlying database errors during read/write operations."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.code,{children:"RuntimeError"})}),": For critical internal errors, such as an inability to generate a unique name after many attempts."]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"example",children:"Example"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'from pathlib import Path\nfrom satif_ai.utils import merge_sdif_files # Adjust import based on your project structure\n\n# Define paths to your source SDIF files\nsdif_file_1 = "path/to/your/first_dataset.sdif"\nsdif_file_2 = "path/to/your/second_dataset.sdif"\n\n# Define the desired full path for the merged output file\nmerged_output = "path/to/merged/combined_data.sdif"\n\ntry:\n    # Perform the merge\n    final_merged_path = merge_sdif_files(\n        sdif_paths=[sdif_file_1, sdif_file_2],\n        output_path=merged_output\n    )\n    print(f"SDIF files successfully merged into: {final_merged_path}")\n\nexcept FileNotFoundError as e:\n    print(f"Error: Source file not found - {e}")\nexcept ValueError as e:\n    print(f"Error: Invalid input - {e}")\nexcept Exception as e:\n    print(f"An unexpected error occurred: {e}")\n\n'})})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,i,s)=>{s.d(i,{R:()=>d,x:()=>l});var n=s(6540);const t={},r=n.createContext(t);function d(e){const i=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);