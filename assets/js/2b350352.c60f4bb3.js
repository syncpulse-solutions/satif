"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8921],{2080:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"api_reference/satif_sdk/standardizers/csv","title":"satif_sdk.standardizers.csv","description":"CSVStandardizer Objects","source":"@site/docs/api_reference/satif_sdk/standardizers/csv.md","sourceDirName":"api_reference/satif_sdk/standardizers","slug":"/api_reference/satif_sdk/standardizers/csv","permalink":"/satif/docs/api_reference/satif_sdk/standardizers/csv","draft":false,"unlisted":false,"editUrl":"https://github.com/syncpulse-solutions/satif/tree/main/docs/docs/api_reference/satif_sdk/standardizers/csv.md","tags":[],"version":"current","frontMatter":{"sidebar_label":"csv","title":"satif_sdk.standardizers.csv"},"sidebar":"tutorialSidebar","previous":{"title":"xlsx","permalink":"/satif/docs/api_reference/satif_sdk/representers/xlsx"},"next":{"title":"pdf","permalink":"/satif/docs/api_reference/satif_sdk/standardizers/pdf"}}');var r=i(4848),t=i(8453);const d={sidebar_label:"csv",title:"satif_sdk.standardizers.csv"},o=void 0,l={},a=[{value:"CSVStandardizer Objects",id:"csvstandardizer-objects",level:2},{value:"__init__",id:"__init__",level:4},{value:"standardize",id:"standardize",level:4}];function c(e){const n={blockquote:"blockquote",code:"code",em:"em",h2:"h2",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"csvstandardizer-objects",children:"CSVStandardizer Objects"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class CSVStandardizer(Standardizer)\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Standardizer for one or multiple CSV files into a single SDIF database."}),"\n",(0,r.jsxs)(n.p,{children:["Transforms CSV data into the SDIF format, handling single or multiple files.\nDefault CSV parsing options (delimiter, encoding, header, skip_rows,\nskip_columns) are set during initialization. These defaults can\nbe overridden on a per-file basis when calling the ",(0,r.jsx)(n.code,{children:"standardize"})," method.\nIncludes basic type inference for columns (INTEGER, REAL, TEXT)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Attributes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"default_delimiter"})," ",(0,r.jsx)(n.em,{children:"Optional[str]"})," - Default CSV delimiter character. If None, attempts auto-detection."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"default_encoding"})," ",(0,r.jsx)(n.em,{children:"Optional[str]"})," - Default file encoding. If None, attempts auto-detection."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"default_has_header"})," ",(0,r.jsx)(n.em,{children:"bool"})," - Default assumption whether CSV files have a header row."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"default_skip_rows"})," ",(0,r.jsx)(n.em,{children:"SkipRowsConfig"})," - Raw config for rows to skip, validated from constructor."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"default_skip_columns"})," ",(0,r.jsx)(n.em,{children:"SkipColumnsConfig"})," - Raw config for columns to skip, validated from constructor."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"descriptions"})," ",(0,r.jsx)(n.em,{children:"Optional[Union[str, List[Optional[str]]]]"})," - Descriptions for the data sources."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"table_names"})," ",(0,r.jsx)(n.em,{children:"Optional[Union[str, List[Optional[str]]]]"})," - Target table names in the SDIF database."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"file_configs"})," ",(0,r.jsx)(n.em,{children:"Optional[Union[Dict[str, CSVFileConfig], List[Optional[CSVFileConfig]]]]"})," - File-specific configuration overrides."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"column_definitions"})," ",(0,r.jsx)(n.em,{children:"ColumnDefinitionsConfig"})," - Column definitions for the data sources."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"__init__",children:"__init__"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def __init__(\n    delimiter: Optional[str] = None,\n    encoding: Optional[str] = None,\n    has_header: bool = True,\n    skip_rows: SkipRowsConfig = 0,\n    skip_columns: SkipColumnsConfig = None,\n    descriptions: Optional[Union[str, List[Optional[str]]]] = None,\n    table_names: Optional[Union[str, List[Optional[str]]]] = None,\n    column_definitions: ColumnDefinitionsConfig = None,\n    file_configs: Optional[Union[Dict[str, CSVFileConfig],\n                                 List[Optional[CSVFileConfig]]]] = None)\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Initialize the CSV standardizer with default and task-specific configurations."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"delimiter"})," - Default CSV delimiter character. If None, attempts auto-detection.\nIf auto-detection fails, defaults to ',' with a warning."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"encoding"})," - Default file encoding. If None, attempts auto-detection using charset-normalizer.\nIf auto-detection fails, defaults to 'utf-8' with a warning."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"has_header"})," - Default assumption whether CSV files have a header row."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"skip_rows"})," - Rows to skip. Can be:\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["An ",(0,r.jsx)(n.code,{children:"int"}),": Skips the first N rows."]}),"\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"List[int]"})," or ",(0,r.jsx)(n.code,{children:"Set[int]"}),": Skips rows by their specific 0-based index (negative indices count from end).\nDefaults to 0 (skip no rows). Non-negative indices only for positive specification."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"skip_columns"})," - Columns to skip. Can be:\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["An ",(0,r.jsx)(n.code,{children:"int"})," or ",(0,r.jsx)(n.code,{children:"str"}),": Skip a single column by 0-based index or name."]}),"\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"encoding"}),"0 or ",(0,r.jsx)(n.code,{children:"encoding"}),"1 containing ",(0,r.jsx)(n.code,{children:"int"})," or ",(0,r.jsx)(n.code,{children:"str"}),": Skip multiple columns by index or name.\nColumn names are only effective if ",(0,r.jsx)(n.code,{children:"encoding"}),"4. Non-negative indices only.\nDefaults to None (skip no columns)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"encoding"}),"5 - A single description for all sources, or a list of\ndescriptions (one per input file expected in standardize).\nIf None, descriptions are omitted. Used for ",(0,r.jsx)(n.code,{children:"encoding"}),"6."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"encoding"}),"7 - A single table name (used as a base if multiple files),\na list of table names (one per input file expected in standardize), or None.\nIf None, table names are derived from input filenames."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"encoding"}),"8 - Optional configuration overrides. Can be a single dict\napplied to all files, or a list of dicts (one per file expected\nin standardize, use None in list to apply defaults). Keys in the dict\ncan include 'delimiter', 'encoding', 'has_header',\n'skip_rows', 'skip_columns', 'description', 'table_name', 'column_definitions'.\nThese override the defaults set above."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"encoding"}),"9 - Provides explicit definitions for columns, overriding automatic header\nprocessing or inference. This allows renaming columns, selecting specific\ncolumns, and providing descriptions. Types are still inferred.\nCan be:\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"has_header"}),"0: Defines columns for a single table. If multiple input\nfiles are processed and this single list is provided, it's applied to each.\nEach ",(0,r.jsx)(n.code,{children:"has_header"}),"1 is a dict:"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"has_header"}),'2{"original_identifier"',(0,r.jsx)(n.code,{children:"has_header"}),"3"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"has_header"}),"2original_identifier",(0,r.jsx)(n.code,{children:"has_header"}),"2 ",(0,r.jsx)(n.em,{children:"str"})," - Name or 0-based index (as str) in the CSV."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"has_header"}),"2final_column_name",(0,r.jsx)(n.code,{children:"has_header"}),"2 ",(0,r.jsx)(n.em,{children:"str"})," - Desired name in the SDIF table."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"has_header"}),"2description",(0,r.jsx)(n.code,{children:"has_header"}),"2 ",(0,r.jsx)(n.em,{children:"str, optional"})," - Column description.\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"skip_rows"}),"0: Maps final table names to their column specs.\nUseful when ",(0,r.jsx)(n.code,{children:"encoding"}),"7 are known and you want to define columns per table."]}),"\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"skip_rows"}),"2:\nA list corresponding to each input file. Each element can be ",(0,r.jsx)(n.code,{children:"skip_rows"}),"3 (use default\nhandling), a ",(0,r.jsx)(n.code,{children:"has_header"}),"0 for that file's table, or a\n",(0,r.jsx)(n.code,{children:"skip_rows"}),"0 if that file might map to specific table names\n(though CSV standardizer typically creates one table per file)."]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"skip_rows"}),"3 (default), columns are derived from CSV header or generated, and types inferred."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"standardize",children:"standardize"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def standardize(datasource: Datasource,\n                output_path: SDIFPath,\n                *,\n                overwrite: bool = False) -> StandardizationResult\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Standardize one or more CSV files into a single SDIF database file,\nusing configurations provided during initialization or overridden per file."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"datasource"})," - A single file path (str or Path) or a list of file paths\nfor the CSV files to be standardized."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"output_path"})," - The path (str or Path) where the output SDIF database\nfile will be created."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"overwrite"})," - If True, an existing SDIF file at ",(0,r.jsx)(n.code,{children:"output_path"})," will be\noverwritten. Defaults to False (raises an error if file exists)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,r.jsx)(n.p,{children:"A StandardizationResult object containing the path to the created\nSDIF file and a dictionary of the final configurations used for each\nprocessed input file."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Raises"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"FileNotFoundError"})," - If an input CSV file is not found."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ValueError"})," - If input parameters are invalid (e.g., no input datasource,\ninput path is not a file)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"TypeError"})," - If datasource type is incorrect.\nVarious other exceptions from underlying CSV parsing or database operations\ncan also be raised if critical errors occur."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>o});var s=i(6540);const r={},t=s.createContext(r);function d(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);