"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6701],{1516:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>c,toc:()=>d});const c=JSON.parse('{"id":"api_reference/sdif_db/schema","title":"sdif_db.schema","description":"SDIFSchemaConfig Objects","source":"@site/docs/api_reference/sdif_db/schema.md","sourceDirName":"api_reference/sdif_db","slug":"/api_reference/sdif_db/schema","permalink":"/satif/docs/api_reference/sdif_db/schema","draft":false,"unlisted":false,"editUrl":"https://github.com/syncpulse-solutions/satif/tree/main/docs/docs/api_reference/sdif_db/schema.md","tags":[],"version":"current","frontMatter":{"sidebar_label":"schema","title":"sdif_db.schema"},"sidebar":"tutorialSidebar","previous":{"title":"database","permalink":"/satif/docs/api_reference/sdif_db/database"},"next":{"title":"utils","permalink":"/satif/docs/api_reference/sdif_db/utils"}}');var r=s(4848),i=s(8453);const a={sidebar_label:"schema",title:"sdif_db.schema"},l=void 0,o={},d=[{value:"SDIFSchemaConfig Objects",id:"sdifschemaconfig-objects",level:2},{value:"apply_rules_to_schema",id:"apply_rules_to_schema",level:4}];function t(e){const n={blockquote:"blockquote",code:"code",h2:"h2",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"sdifschemaconfig-objects",children:"SDIFSchemaConfig Objects"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class SDIFSchemaConfig()\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Configuration for comparing SDIF structural schemas. Defines which aspects of the\nschema to enforce during comparison."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Attributes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_sdif_version"})," - If True, compares the 'sdif_version' from properties."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_table_names"})," - If True, tables are matched by name. If False, the set of\ntable structures is compared, ignoring original names."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_column_order"})," - If True, the order of columns within a table must match."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_column_names"})," - If True, columns are matched by name. If False (and\nenforce_column_order is True), columns are compared by their position."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_column_types"})," - If True, SQLite data types of columns must match."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_column_not_null_constraints"})," - If True, NOT NULL constraints must match."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_column_default_values"})," - If True, column default values must match."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_primary_keys"})," - If True, compares the ordered list of column names\nforming each table's primary key."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_foreign_keys"})," - If True, compares foreign key definitions (target table,\nordered source/target columns)."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_foreign_key_referential_actions"})," - If True (and enforce_foreign_keys is\nTrue), 'ON UPDATE' and 'ON DELETE' referential actions must match."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_table_names"}),"0 - Defines how JSON objects in 'sdif_objects' are compared."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_table_names"}),"1 - Objects are not compared."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_table_names"}),"2 - Only the set of object names is compared."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_table_names"}),"3 - Object names and the content of their\n'schema_hint' (if present and valid) are compared."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_table_names"}),"4 - Defines how media items in 'sdif_media' are compared."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_table_names"}),"1 - Media items are not compared."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_table_names"}),"2 - Only the set of media names is compared."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_table_names"}),"7 - Media names and 'media_type' are compared."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_table_names"}),"8 - Media names, 'media_type', and\n'original_format' are compared."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_table_names"}),"9 - Defines how 'technical_metadata' for media\nitems is compared."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_table_names"}),"1 - Technical metadata is not compared."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_column_order"}),"1 - The content of 'technical_metadata' (if present\nand valid JSON) is compared."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_column_order"}),"2 - Defines how links in 'sdif_semantic_links' are compared."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_table_names"}),"1 - Semantic links are not compared."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_column_order"}),"4 - Only the set of unique 'link_type' values is compared."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enforce_column_order"}),"5 - All structural aspects of links (type, from/to element\ntype and spec, excluding 'link_id' and 'description')\nare compared."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,r.jsx)(n.p,{children:"Comparison of non-primary-key UNIQUE constraints and CHECK constraints on tables\nis currently NOT SUPPORTED, as SDIFDatabase.get_schema() does not extract them."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"apply_rules_to_schema",children:"apply_rules_to_schema"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def apply_rules_to_schema(full_schema: Dict[str, Any],\n                          config: SDIFSchemaConfig) -> Dict[str, Any]\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Transforms a full structural schema (from SDIFDatabase.get_schema())\ninto a minimal, canonical schema based on the provided configuration."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"full_schema"})," - The schema dictionary from SDIFDatabase.get_schema()."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"config"})," - An SDIFSchemaConfig instance defining the comparison rules."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,r.jsx)(n.p,{children:"A minimal, canonical schema dictionary, ready for direct comparison."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var c=s(6540);const r={},i=c.createContext(r);function a(e){const n=c.useContext(i);return c.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),c.createElement(i.Provider,{value:n},e.children)}}}]);