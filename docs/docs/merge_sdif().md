---
sidebar_position: 8
---
# Merging SDIF Files

The `merge_sdif_files` utility provides a robust mechanism to consolidate multiple SDIF files into a single, new SDIF file. This is useful for combining datasets that have been standardized separately.

## Function Signature

```python
from pathlib import Path
from typing import List
from satif_core.types import SDIFPath

def merge_sdif_files(sdif_paths: List[SDIFPath], output_path: Path) -> Path:
    # ... implementation ...
```

## Parameters

* **`sdif_paths` (List[SDIFPath])**: A list of paths to the source SDIF files that need to be merged.
* **`output_path` (Path)**: The full file path where the newly merged SDIF file will be saved.
  * Its parent directory will be created if it doesn't exist.
  * If `output_path` points to an existing file, that file **will be overwritten**.
  * If `output_path` points to an existing directory, a `ValueError` is raised.

## Returns

* **(Path)**: The path to the newly created and merged SDIF file (this will be the same as the `output_path` provided).

## Core Merging Heuristics and Rules

The merge process iterates through each source SDIF file and integrates its contents into a new target SDIF database according to the following rules:

### 1. Target SDIF File

* A new SQLite database is created at the specified `output_path`. If a file already exists at `output_path`, it is overwritten.

### 2. Single File Input

* If `sdif_paths` contains only one file path:
  * No actual merge operation is performed.
  * The single source SDIF file is copied directly to the `output_path`.
  * If the source file and `output_path` are identical, no copy occurs.

### 3. Metadata Tables (`sdif_`)

#### `sdif_properties`

* **`sdif_version`**: The `sdif_version` from the `sdif_properties` table of the *first* SDIF file in the `sdif_paths` list is used for the merged file.
  * **Heuristic**: It's assumed all source SDIF files conform to the same base SDIF specification (currently "1.0"). The function will raise a `ValueError` if a source SDIF has a version other than "1.0".
* **`creation_timestamp`**: This is set to the Coordinated Universal Time (UTC) when the entire merge operation successfully completes for the target merged file.

#### `sdif_sources`

* All entries from the `sdif_sources` table of each source SDIF are copied into the target SDIF's `sdif_sources` table.
* **`source_id` Remapping**: New `source_id` primary keys are generated in the target database. A mapping from the (source file index, old `source_id`) to the new `source_id` is maintained internally to update references in other tables (like `sdif_tables_metadata`, `sdif_objects`, `sdif_media`).
* **`processing_timestamp`**: The original `processing_timestamp` for a source is not directly carried over. The `SDIFDatabase.add_source()` method, when adding these sources to the target, will generate a new `processing_timestamp` reflecting when that source entry was added to the *merged* file.

#### `sdif_tables_metadata` and `sdif_columns_metadata` (User Data Tables)

* **Schema Integration**: For each user data table found in a source SDIF:
  * The table's schema (column names, SQLite types, `NOT NULL`, `PRIMARY KEY`, `FOREIGN KEY` constraints, descriptions, original column names) is retrieved from the source SDIF using `SDIFDatabase.get_schema()`.
* **Table Name Conflict Resolution**:
  * **Heuristic**: If a table name from a source SDIF already exists in the target merged SDIF (due to a previous source SDIF having a table with the same name), a unique name is generated by appending an underscore and a sequential number (e.g., `my_table` becomes `my_table_1`, then `my_table_2`, etc.).
  * This new (or original, if no conflict) table name is used for creation in the target and for remapping any references.
* **`source_id` Update**: The `source_id` in `sdif_tables_metadata` is updated to the new `source_id` generated for its original source in the target database.
* **Foreign Key (FK) Remapping**:
  * **Heuristic**: Foreign key constraints defined within a source SDIF are assumed to target tables *also originating from that same source SDIF file*.
  * When a table is created in the target, its FK definitions are updated to point to the new (potentially renamed) names of its target tables *as they exist in the current merge context (i.e., after their own potential renaming)*.
  * Cross-SDIF file foreign key relationships are not automatically established or inferred by this merge process.
* **Data Copying**: All rows from the source table are copied into the newly created (and potentially renamed) table in the target SDIF.
  * **Type Handling**: Basic data type conversions are applied to align pandas DataFrame types with SQLite expectations during insertion (e.g., Python booleans to integers 0/1, pandas `NaT` to `None`, datetime objects to ISO 8601 strings).

#### `sdif_objects`

* Each JSON object entry from a source `sdif_objects` table is copied.
* **`object_name` Conflict Resolution**: Similar to table names, if an `object_name` already exists in the target, a unique name (e.g., `my_object_1`) is generated.
* **`source_id` Update**: The `source_id` is remapped to its new value in the target.
* **`json_data` and `schema_hint`**: The JSON content and schema hint are preserved.

#### `sdif_media`

* Each media asset entry from a source `sdif_media` table is copied.
* **`media_name` Conflict Resolution**: Unique names are generated for `media_name` if conflicts arise (e.g., `my_image_1`).
* **`source_id` Update**: The `source_id` is remapped.
* **`media_data` and Metadata**: The binary `media_data` (BLOB) and all associated metadata (`media_type`, `description`, `original_format`, `technical_metadata`) are preserved.

#### `sdif_semantic_links`

* Entries from the `sdif_semantic_links` table are copied.
* **Element Specification Remapping (`from_element_spec`, `to_element_spec`)**:
  * The JSON content of `from_element_spec` and `to_element_spec` is parsed.
  * If these specifications refer to elements by name (e.g., `table_name`, `object_name`, `media_name`), these names are updated to their new (potentially conflict-resolved) names in the target merged SDIF.
  * If a specification contains a `source_id` (relevant for certain `element_type` values, though less common directly in link specs compared to annotations), it's also remapped.
  * **Heuristic**: Links are assumed to be self-contained within the scope of elements originating from the *same source SDIF file*. The remapping ensures these internal links remain consistent after potential renaming of their constituent parts.

#### `sdif_annotations`

* **Not Merged**: The `sdif_annotations` table is **not** processed or merged in the current version of `merge_sdif_files`. Its contents from source SDIFs will not be present in the merged output file. This is an optional table per RFC SP-RFC-002, and merging it involves significant complexity in remapping target elements.

## Error Handling

The function may raise common exceptions, including:

* **`ValueError`**: If `sdif_paths` is empty, or `output_path` is an existing directory or otherwise invalid.
* **`FileNotFoundError`**: If any of the specified source SDIF files in `sdif_paths` do not exist.
* **`sqlite3.Error` (and subclasses)**: For underlying database errors during read/write operations.
* **`RuntimeError`**: For critical internal errors, such as an inability to generate a unique name after many attempts.

## Example

```python
from pathlib import Path
from satif_ai.utils import merge_sdif_files # Adjust import based on your project structure

# Define paths to your source SDIF files
sdif_file_1 = "path/to/your/first_dataset.sdif"
sdif_file_2 = "path/to/your/second_dataset.sdif"

# Define the desired full path for the merged output file
merged_output = "path/to/merged/combined_data.sdif"

try:
    # Perform the merge
    final_merged_path = merge_sdif_files(
        sdif_paths=[sdif_file_1, sdif_file_2],
        output_path=merged_output
    )
    print(f"SDIF files successfully merged into: {final_merged_path}")

except FileNotFoundError as e:
    print(f"Error: Source file not found - {e}")
except ValueError as e:
    print(f"Error: Invalid input - {e}")
except Exception as e:
    print(f"An unexpected error occurred: {e}")

```
